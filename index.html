<!DOCTYPE html>
<html lang="en">
<!-- Previous head and style sections remain the same until three-section -->
<style>
  /* ... (previous styles) ... */
  
  .three-section {
    position: fixed; /* Change to fixed position */
    top: 180px; /* Position below header */
    left: 50%;
    transform: translateX(-50%);
    width: 100%;
    max-width: 900px;
    height: 400px; /* Fixed height */
    z-index: 1;
    pointer-events: none; /* Allow clicks to pass through */
  }

  #three-container {
    width: 100%;
    max-width: 740px;
    height: 100%;
    margin: 0 auto;
    border-radius: 24px;
    box-shadow: 0 0 44px #fff, 0 2px 18px #000;
    background: rgba(17, 17, 17, 0.8);
    overflow: hidden;
    position: relative;
    pointer-events: auto; /* Re-enable pointer events */
  }

  /* Add padding to content to prevent overlap */
  .content {
    margin-top: 460px; /* Space for 3D section */
    position: relative;
    z-index: 2;
    background: rgba(0, 0, 0, 0.9);
    padding: 40px 20px;
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
  }
</style>

<!-- ... (rest of HTML remains same until script) ... -->

<script>
  // ... (previous script code until component creation) ...

  // Remove previous component creation functions and replace with these:

  function createTower(x, y, z, height = 24) {
    const group = new THREE.Group();
    
    // Base structure
    const baseGeom = new THREE.CylinderGeometry(2, 3, height, 6);
    const baseMat = makeWhiteMaterial(0.7);
    const base = new THREE.Mesh(baseGeom, baseMat);
    group.add(base);

    // Platforms
    for(let i = 0; i < 3; i++) {
      const platformGeom = new THREE.CylinderGeometry(4, 4, 1, 6);
      const platform = new THREE.Mesh(platformGeom, baseMat);
      platform.position.y = height/4 * (i-1);
      group.add(platform);
    }

    // Antennas
    for(let i = 0; i < 6; i++) {
      const angle = (i * Math.PI) / 3;
      const antGeom = new THREE.BoxGeometry(0.5, 4, 1);
      const antMat = makeWhiteMaterial(0.9);
      const antenna = new THREE.Mesh(antGeom, antMat);
      antenna.position.set(
        Math.cos(angle) * 3,
        height/3,
        Math.sin(angle) * 3
      );
      antenna.lookAt(new THREE.Vector3(
        Math.cos(angle) * 10,
        height/3,
        Math.sin(angle) * 10
      ));
      group.add(antenna);
    }

    group.position.set(x, y, z);
    scene.add(group);
    return group;
  }

  function createSatellite(x, y, z) {
    const group = new THREE.Group();
    
    // Main body
    const bodyGeom = new THREE.SphereGeometry(3, 16, 16);
    const bodyMat = makeWhiteMaterial(0.8);
    const body = new THREE.Mesh(bodyGeom, bodyMat);
    group.add(body);

    // Solar panels
    const panelGeom = new THREE.BoxGeometry(12, 4, 0.2);
    const panelMat = makeWhiteMaterial(0.6);
    
    const leftPanel = new THREE.Mesh(panelGeom, panelMat);
    leftPanel.position.x = -7;
    group.add(leftPanel);

    const rightPanel = new THREE.Mesh(panelGeom, panelMat);
    rightPanel.position.x = 7;
    group.add(rightPanel);

    // Dish
    const dishGeom = new THREE.SphereGeometry(2, 16, 16, 0, Math.PI);
    const dish = new THREE.Mesh(dishGeom, bodyMat);
    dish.rotation.x = Math.PI/2;
    dish.position.y = -2;
    group.add(dish);

    group.position.set(x, y, z);
    scene.add(group);
    return group;
  }

  function createBuilding(x, y, z, type = "office") {
    const group = new THREE.Group();
    
    let buildingGeom, height;
    switch(type) {
      case "office":
        buildingGeom = new THREE.BoxGeometry(8, 20, 8);
        height = 20;
        break;
      case "house":
        buildingGeom = new THREE.BoxGeometry(6, 8, 6);
        height = 8;
        break;
      case "industry":
        buildingGeom = new THREE.BoxGeometry(16, 12, 12);
        height = 12;
        break;
    }
    
    const buildingMat = makeWhiteMaterial(0.7);
    const building = new THREE.Mesh(buildingGeom, buildingMat);
    group.add(building);

    // Add antenna or dish
    if (type !== "house") {
      const antennaGeom = new THREE.CylinderGeometry(0.3, 0.3, 4, 8);
      const antenna = new THREE.Mesh(antennaGeom, buildingMat);
      antenna.position.y = height/2 + 2;
      group.add(antenna);

      const dishGeom = new THREE.SphereGeometry(1, 16, 16, 0, Math.PI);
      const dish = new THREE.Mesh(dishGeom, buildingMat);
      dish.rotation.x = Math.PI/2;
      dish.position.set(2, height/2, 0);
      group.add(dish);
    }

    group.position.set(x, y, z);
    scene.add(group);
    return group;
  }

  // Create data stream effect
  function createDataStream(start, end) {
    const points = [];
    points.push(new THREE.Vector3(start.x, start.y, start.z));
    
    // Create curve points
    const mid = new THREE.Vector3(
      (start.x + end.x)/2,
      Math.max(start.y, end.y) + 10,
      (start.z + end.z)/2
    );
    points.push(mid);
    points.push(new THREE.Vector3(end.x, end.y, end.z));

    const curve = new THREE.CatmullRomCurve3(points);
    const geometry = new THREE.TubeGeometry(curve, 20, 0.1, 8, false);
    const material = new THREE.MeshPhongMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.3,
      emissive: 0xffffff,
      emissiveIntensity: 0.2
    });

    const tube = new THREE.Mesh(geometry, material);
    scene.add(tube);
    return tube;
  }

  // Place components
  const components = [
    createTower(-30, 0, -20),
    createTower(30, 0, -20),
    createTower(0, 0, 30),
    createSatellite(-20, 40, -10),
    createSatellite(20, 45, 10),
    createBuilding(-25, 0, 10, "office"),
    createBuilding(25, 0, 10, "office"),
    createBuilding(0, 0, -30, "industry"),
    createBuilding(-15, 0, -15, "house"),
    createBuilding(15, 0, -15, "house")
  ];

  // Create data streams
  const dataStreams = [];
  components.forEach((c1, i) => {
    components.slice(i + 1).forEach(c2 => {
      if (Math.random() < 0.3) { // 30% chance to create connection
        dataStreams.push(createDataStream(
          c1.position,
          c2.position
        ));
      }
    });
  });

  // Animate data streams
  const streamMaterials = dataStreams.map(stream => stream.material);
  function animateStreams() {
    streamMaterials.forEach(material => {
      material.opacity = 0.2 + Math.sin(Date.now() / 1000) * 0.1;
    });
  }

  // Update animation function
  function animate() {
    animateStreams();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // ... (rest of the code remains same) ...
</script>
</html>
